# 노출 모듈 패턴(Revealing Module pattern)
- 책 1.1.7 참고

## 정의
- 모듈 내부의 함수나 변수는 **비공개(private)**로 유지하고, 필요한 것만 명시적으로 **공개(public)**하는 방식의 모듈 디자인 패턴

- 모듈 패턴의 변형으로, 반환 객체에서 어떤 멤버를 노출시킬지 명확히 정의함
## 특징
- 내부 구현을 감추고 외부에는 필요한 기능만 노출

- public API와 내부 로직을 명확히 구분

- 일관성 있는 코드 구성 가능 (모든 공개 멤버는 반환 객체에서 정의됨)

- 클로저를 활용한 정보 은닉 가능

## 관련 개념

### 모듈 패턴 (Module Pattern)
- 하나의 객체나 함수 안에 기능들을 캡슐화하여 네임스페이스 충돌 방지 및 은닉 가능

### 클로저 (Closure)
- 함수가 생성될 때의 스코프를 기억하여, 외부에서 접근 불가능한 상태 값을 유지함

### 즉시 실행 함수 표현식 (IIFE, Immediately Invoked Function Expression)
- 함수를 정의함과 동시에 즉시 실행하는 JavaScript 문법

- 외부 스코프에 영향을 주지 않으면서 모듈을 생성할 수 있음

### 캡슐화 (Encapsulation)
- 데이터와 관련된 동작(함수)을 하나의 단위로 묶고, 외부에 필요한 부분만 공개

- 객체지향 설계의 핵심 원칙 중 하나로, 정보 은닉과 모듈화에 도움

### 공용 인터페이스 (Public API)
- 외부에서 접근 가능한 메서드 및 속성을 의미하며, 사용자가 사용할 수 있는 기능만을 명확히 정의

- 일관성 있고 예측 가능한 코드 구조를 가능하게 함


## 장점
- 코드의 응집도 증가 및 의존성 관리 용이

- 코드 은닉으로 보안성과 안정성 증가

- 테스트 및 유지보수가 쉬워짐

- 공개 API를 한눈에 확인할 수 있어 가독성 우수

## 단점
- 너무 많은 은닉은 디버깅 어려움을 초래할 수 있음

- 모듈 단위가 커지면 관리가 복잡해질 수 있음

- 비공개 멤버 테스트가 어려움

```javascript
function outer() {
  let count = 0;

  return function inner() {
    count++;
    return count;
  }
}

const counter = outer();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```
- outer() 가 실행되면서 count라는 변수를 기억하고, 내부함수 inner()는 count를 계속 접근할 수 있음

- 여기서 중요한 건 count는 outer()가 끝났어도 메모리는 살아있음

- →왜? 내부 함수 inner()가 계속 그 count를 기억하고 있기 때문